import os
import asyncio
import tempfile
import shutil
import uvicorn
import yaml
import grpc
from typing import Dict, List, Any, Optional
from fastapi import FastAPI, File, UploadFile, Form, BackgroundTasks
from fastapi.responses import FileResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# Import the gRPC client functionality
from a2f_3d.client.service import read_from_stream, write_to_stream
from nvidia_ace.services.a2f_controller.v1_pb2_grpc import A2FControllerServiceStub

# Define Pydantic models for request/response
class EmotionValue(BaseModel):
    time_code: float
    emotions: Dict[str, float]

class ProcessingParams(BaseModel):
    post_processing_parameters: Dict[str, Any]
    face_parameters: Dict[str, float]
    blendshape_parameters: Dict[str, Dict[str, float]]

# Initialize FastAPI with metadata for Swagger
app = FastAPI(
    title="Audio2Face 3D API",
    description="API for generating facial animations from audio with emotion parameters",
    version="1.0.0",
    docs_url="/swagger",  # Custom Swagger URL
    openapi_url="/openapi.json"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global gRPC channel
channel = grpc.aio.insecure_channel("localhost:52000")
stub = A2FControllerServiceStub(channel)

@app.post("/process", 
          summary="Process audio with emotions",
          description="Send audio file with emotion configuration to generate facial animations")
async def process_audio(
    background_tasks: BackgroundTasks,
    audio_file: UploadFile = File(..., description="Audio file (16-bit PCM WAV)"),
    config_file: UploadFile = File(..., description="YAML configuration file")
):
    # Create temporary directory for files
    temp_dir = tempfile.mkdtemp()
    audio_path = os.path.join(temp_dir, "input.wav")
    config_path = os.path.join(temp_dir, "config.yml")
    
    try:
        # Save audio file
        with open(audio_path, "wb") as f:
            f.write(await audio_file.read())
        
        # Save config file
        with open(config_path, "wb") as f:
            f.write(await config_file.read())
        
        # Process through gRPC
        animation_data = await process_audio_with_grpc(audio_path, config_path)
        
        # Background task to clean up temp files
        background_tasks.add_task(lambda: shutil.rmtree(temp_dir))
        
        return JSONResponse(content=animation_data)
        
    except Exception as e:
        # Clean up on error too
        shutil.rmtree(temp_dir)
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

async def process_audio_with_grpc(audio_path, config_path):
    # Create a bidirectional streaming RPC call
    stream_call = stub.ProcessAudioWithBlendshapes()
    
    # Create tasks for reading and writing to the stream
    write_task = asyncio.create_task(write_to_stream(stream_call, config_path, audio_path))
    read_task = asyncio.create_task(read_from_stream(stream_call))
    
    # Wait for both tasks to complete
    await asyncio.gather(write_task, read_task)
    
    # Return the output directory path (the last one created)
    dirs = [d for d in os.listdir() if os.path.isdir(d) and d[0].isdigit()]
    dirs.sort(reverse=True)
    if dirs:
        latest_dir = dirs[0]
        return {
            "output_directory": latest_dir,
            "files": {
                "animation": f"{latest_dir}/animation_frames.csv",
                "emotions": f"{latest_dir}/a2f_smoothed_emotion_output.csv",
                "input_emotions": f"{latest_dir}/a2f_input_emotions.csv",
                "audio": f"{latest_dir}/out.wav"
            }
        }
    else:
        raise Exception("No output directory was created")

@app.get("/download/{filename:path}", 
         summary="Download generated file",
         description="Download a file generated by the processing")
async def download_file(filename: str):
    if os.path.exists(filename) and os.path.isfile(filename):
        return FileResponse(path=filename)
    return JSONResponse(
        status_code=404,
        content={"error": "File not found"}
    )

if __name__ == "__main__":
    uvicorn.run("swagger_api:app", host="0.0.0.0", port=9999, reload=True)
